#! /usr/bin/env python2

# ytsubs 0.2.6

# Distributed under the terms of the GNU General Public License, version 3

# Requires the gdata-python-client (Python 2):
# http://code.google.com/p/gdata-python-client/

# Usage:
# "ytsubs <username> [<password>]" - omit password to type it in without echo

# Options:
# -s DAYS, --start=DAYS
#   how many days ago to start the feed at; defaults to 14

# Prints the RSS feed to stdout (pipe it to a file or something).  At the
# moment, videos are restricted to those published in the last 2 weeks.

# TODO:
# - doesn't work for 'shows'?
# - multiple pages of subscribers

import sys
import socket
import time
from signal import signal, SIGINT, SIGTERM
from getpass import getpass
from xml.etree.ElementTree import XML, tostring as xml_to_string
from xml.sax.saxutils import escape as escape_xml
import urlparse
from urllib import urlencode
from optparse import OptionParser

from gdata.youtube.service import YouTubeService
from gdata import service as gservice

YT_DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.000Z'
FEED_DATE_FORMAT = '%a, %d %b %Y %H:%M:%S %Z'
FEED_TEMPLATE = '''<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>YouTube subscriptions</title>
        <link>https://www.youtube.com/my_subscriptions</link>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <lastBuildDate>{0}</lastBuildDate>
    </channel>
</rss>'''


def err (s):
    print >> sys.stderr, s


def login (user, pwd):
    yt = YouTubeService()
    yt.email = user
    yt.password = pwd
    try:
        yt.ProgrammaticLogin()
    except gservice.BadAuthentication:
        return None
    else:
        return yt


def get_vids (yt, earliest):
    subs = yt.GetYouTubeSubscriptionFeed().entry
    uri = 'http://gdata.youtube.com/feeds/api/users/{0}/uploads'
    vids = []
    for sub in subs:
        name = sub.username.text
        err(name)
        this_vids = []
        feed = yt.GetYouTubeVideoFeed(uri.format(name))
        while True:
            this_vids += feed.entry
            t = time.strptime(this_vids[-1].published.text, YT_DATE_FORMAT)
            if time.mktime(t) < earliest:
               # got all the videos we want
                break
            # request more videos
            link = feed.GetNextLink()
            if link is None:
                break
            feed = yt.GetYouTubeSubscriptionFeed(link.href)
        for v in this_vids:
            t = time.mktime(time.strptime(v.published.text, YT_DATE_FORMAT))
            if t < earliest:
                break
            vids.append((t, v, name))
    vids.sort(reverse = True)
    return vids


def mk_feed (vids):
    xml = XML(FEED_TEMPLATE.format(time.strftime(FEED_DATE_FORMAT,
                                                 time.localtime())))
    channel = xml[0]
    for t, v, sub in vids:
        title = '{0}: \'{1}\''.format(sub, v.media.title.text)
        url = v.media.player.url
        # remove all query string items from URL except video ID
        url = urlparse.urlsplit(url)
        qs = url.query
        url = list(url)
        url[url.index(qs)] = urlencode({'v': urlparse.parse_qs(qs)['v'][0]})
        guid = url = urlparse.urlunsplit(url)
        # add as RSS item
        desc = v.media.description.text
        if desc:
            desc = '<p>' + '</p>\n<p>'.join(desc.splitlines()) + '</p>'
        else:
            desc = ''
        if v.media.thumbnail:
            desc = '<img src="{0}">\n'.format(v.media.thumbnail[0].url) + desc
        args = (title, url, desc,
                time.strftime(FEED_DATE_FORMAT, time.gmtime(t)), guid)
        s = '''
        <item>
            <title>{0}</title>
            <link>{1}</link>
            <description>{2}</description>
            <pubDate>{3}</pubDate>
            <published>{3}</published>
            <guid>{4}</guid>
        </item>'''.format(*(escape_xml(arg) for arg in args))
        channel.append(XML(s))
    # update build time
    return xml_to_string(xml)


if __name__ == '__main__':
    # handle signals
    quit = lambda *args: sys.exit(0)
    signal(SIGINT, quit)
    signal(SIGTERM, quit)
    # parse arguments
    op = OptionParser(prog = 'ytsubs',
                      usage = 'ytsubs [options...] <username> [<password>]')
    op.add_option('-s', '--start', action = 'store', type = 'int',
                  metavar = 'DAYS', default = 14,
                  help = 'how many days ago to start the feed at; defaults to '
                         '14')
    options, args = op.parse_args()
    if len(args) < 1:
        err('error: expected username argument')
        sys.exit(1)
    elif len(args) < 2:
        pwd = getpass()
    else:
        pwd = args[1]
    # do the stuff
    try:
        yt = login(args[0], pwd)
        if yt is None:
            err('error: can\'t log in')
            sys.exit(1)
        vids = get_vids(yt, time.time() - 60 * 60 * 24 * options.start)
    except socket.gaierror:
        err('error: can\'t connect to the YouTube service')
        sys.exit(1)
    print mk_feed(vids)
